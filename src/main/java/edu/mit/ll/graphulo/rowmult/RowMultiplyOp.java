package edu.mit.ll.graphulo.rowmult;

import edu.mit.ll.graphulo.skvi.TwoTableIterator;
import org.apache.accumulo.core.data.Key;
import org.apache.accumulo.core.data.Value;
import org.apache.accumulo.core.iterators.IteratorEnvironment;
import org.apache.accumulo.core.iterators.SortedKeyValueIterator;

import java.io.IOException;
import java.util.Iterator;
import java.util.Map;

/**
 * Called on every two colliding rows in TwoTableIterator,
 * that is, every two rows in table A and B that match in row.
 */
public interface RowMultiplyOp {

  /**
   * Initializes the row multiply object.
   * Options are passed from <tt>rowMultiplyOp.opt.OPTION_NAME</tt> in the options for {@link TwoTableIterator}.
   *
   * @param options
   *          <tt>Map</tt> map of string option names to option values.
   * @param env
   *          <tt>IteratorEnvironment</tt> environment in which iterator is being run.
   * @throws IOException
   *           unused.
   * @exception IllegalArgumentException
   *              if there are problems with the options.
   */
  void init(Map<String,String> options, IteratorEnvironment env) throws IOException;

  /**
   * When emitNoMatchA and <tt>emitNoMatchB</tt> are false, this method is always called with both arguments non-null.
   * The two iterators will have a top key that matches in row, and that key is the first in the row for each table.
   * <p>
   * Post-condition: non-null SKVI arguments should be seeked to the beginning of the <b>next</b> row.
   * <p>
   * When emitNoMatchA is true, this method will be called with skviB null, when there is a row that exists in B
   * but does not exist in A.  In this case, skviA's top entry is at the beginning of such a row.
   * Vice versa occurs for when <tt>emitNoMatchA</tt> is true.
   * Ordinary usage will never see this. Both <tt>emitNoMatchA</tt> and <tt>emitNoMatchB</tt> default to false.
   *
   * @param skviA If non-null, Table A SKVI with {@link SortedKeyValueIterator#hasTop()} == true and {@link SortedKeyValueIterator#getTopKey()} matching skviB's Row.
   * @param skviB If non-null, Table B SKVI with {@link SortedKeyValueIterator#hasTop()} == true and {@link SortedKeyValueIterator#getTopKey()} matching skviA's Row.
   * @return An iterator over entries generated by the multiplication of the two aligned rows.
   */
  Iterator<Map.Entry<Key,Value>> multiplyRow(SortedKeyValueIterator<Key,Value> skviA,
                                             SortedKeyValueIterator<Key,Value> skviB) throws IOException;

}
